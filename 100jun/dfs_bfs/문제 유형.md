dfs : 깊이우선탐색
1. 스택 또는 재귀함수로 구현 : stack 구조는 FILO(First In Last Out)
import sys
sys.setrecursionlimit(10**6)
2. 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색
bfs : 너비우선탐색
1. 큐로 구현 : queue 구조는 FIFO(First In First Out)
from collections import deque
2. 현재 정점에 연결된 가까운 점들부터 탐색 

따라서 queue는 (출력장소)( a, b, c )(입력장소)인 자료구조라서 FIFO의 성질을 가집니다. 마찬가지로 stack은 (a, b, c)(출력장소/입력장소)인 자료구조라서 FILO의 성질을 가집니다.
기본적인 명령어를 알기위해 stack부터 알아보겠습니다. stack에서 입력은 push(), 출력은 pop()입니다. (참고로 push() 는 action이어서 return 값은 None이고, pop()은 마지막에 저장된 자료값을 뽑아내는 것이니 return값은 마지막 입력값입니다.)
여기서 주의할게 pop()입니다. list등 다양한 자료구조에서 같은 방식으로 사용되는데 오른쪽으로 원소를 빼낸다는 의미입니다.(빼낸다는 개념을 이해하시길 바랍니다. 입력값을 출력함과 동시에 stack에서 그 값을 삭제하는 것입니다.)
queue의 명령어는 입력인 push()와 출력인 popleft()입니다. stack의 pop()과 차이를 두기 위해서 왼쪽으로 빼낸다는 의미인 popleft()를 사용하는 것입니다. => "여기까지가 간단한 stack과 queue의 내용입니다."
deque는 Double-ended Queue를 의미하는데 해석하자면 양끝단을 가진 queue라는 겁니다. 즉 양쪽방향으로 입출력을 모두 다 하겠다는 의미입니다. 따라서 왼쪽으로 출력뿐만 아니라 입력이 가능하고, 오른쪽으로 입력뿐만 아니라 출력이 가능한 queue입니다. 파이썬 deque에선 입력함수로 append(), appendleft(),  출력함수로 popleft(), pop()를 사용합니다.

** 각 특징에 따라 사용에 더 적합한 문제 유형이 존재 **
- 그래프의 모든 정점을 방문하는 것이 주요한 문제 => dfs와 bfs 두 방법 다 사용 가능
- 경로의 특징을 저장해둬야 하는 문제 -> 시작점부터 출발해 목적지까지 가는 경로를 구할 때, 같은 숫자가 있으면 안 된다는 문제 등, 각각의 경로마다 특징을 저장해둬야 할 때는 dfs를 사용  (* bfs는 경로 특징을 못 가짐) 
- 최단거리 구해야 하는 문제 -> 미로 찾기 등 최단 거리를 구해야 할 경우 bfs가 유리 
- 검색 대상 그래프가 정말 크다면 dfs를 고려
- 검색 대상 규모가 크지 않고, 검색 시작 지점으로 부터 원하는 대상이 별로 멀지 않다면 bfs  
